# Implementation Plan: Content Authoring and Versioning

**Branch**: `003-content-authoring-versioning` | **Date**: 2026-01-27 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/003-content-authoring-versioning/spec.md`

## Summary

This plan delivers a branch-bound content authoring and versioning system for Echo Portal. Contributors create, modify, and evolve structured design knowledge (guidelines, assets, Opinions) within explicit branches. Every modification produces a new immutable version identified by its ISO 8601 timestamp, preserving authorship, intent, and lineage. Published content represents stable truth and cannot be directly mutated; evolution occurs through new branches. The system integrates with the existing branch lifecycle, review workflow, permissions model, and audit infrastructure.

The implementation extends the current PostgreSQL + Drizzle ORM data model with `contents`, `content_versions`, and `content_references` tables. Content bodies are stored in PostgreSQL (JSONB for structured content, text for markdown) with a 50 MB size limit. The existing git-backed branch isolation model, XState workflow machine, and RBAC permission system are leveraged and extended rather than replaced.

## Technical Context

**Language/Version**: TypeScript 5.9, Node.js 20 LTS
**Primary Dependencies**: Hono 4.8.2 (backend), React 19 (frontend), Drizzle ORM 0.44.0, XState 5.19.2, Zod 3.24.2, Monaco Editor 0.52.2, TanStack React Query 5.75.5, Zustand 5.0.4
**Storage**: PostgreSQL (existing `echo_portal` database) + existing git repository layer
**Testing**: Vitest (existing test runner)
**Target Platform**: Web application (Node.js backend + React SPA frontend)
**Project Type**: Web application (backend + frontend monorepo with shared package)
**Performance Goals**: Version history retrieval < 3s, version comparison < 5s, 1,000 concurrent contributors (SC-003, SC-007, SC-004)
**Constraints**: 50 MB max content size per item (FR-025), ISO 8601 timestamp-based version IDs (FR-024), 7-year audit retention
**Scale/Scope**: 1,000+ concurrent contributors, indefinite version retention, multiple content types

## Constitution Check

- [x] **Explicit Change Control (I)**: Every content modification creates an immutable version with author attribution, timestamp, and change description. No unversioned edits possible.
- [x] **Single Source of Truth (II)**: Published content is immutable. Updates require new branches. Published versions are locked at the database constraint level.
- [x] **Branch-First Collaboration (III)**: All content must exist within a branch (FR-001). Content cannot be created or modified outside a branch context.
- [x] **Separation of Concerns (IV)**: Read-only published content API is separate from branch-scoped authoring API. Anonymous users consume; contributors author in branches.
- [x] **Role-Driven Governance (V)**: Six actor types defined with explicit permissions. Existing RBAC system extended with content-specific permissions.
- [x] **Open by Default (VI)**: Published public content is accessible without authentication. Visibility boundaries enforce restrictions only where justified.
- [x] **Layered Architecture (VII)**: Content service layer sits alongside existing branch/review services. API contracts are versioned. Schema changes are additive migrations.
- [x] **Specification Completeness (VIII)**: Spec includes all required sections: user stories, requirements, entities, actors, lifecycle, visibility, audit, success criteria.
- [x] **Clarity Over Breadth (IX)**: No complexity violations identified. Content versioning uses timestamp-based IDs (simpler than semantic versioning). No new infrastructure required.
- [x] **Testing as Contract (X)**: Test strategy covers unit, integration, contract, and performance. 90% minimum coverage for core workflows.

## Project Structure

### Documentation (this feature)

```text
specs/003-content-authoring-versioning/
├── spec.md                  # Feature specification
├── plan.md                  # This implementation plan
├── checklists/
│   └── requirements.md      # Quality validation checklist
└── tasks.md                 # Task breakdown (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
backend/
├── src/
│   ├── db/
│   │   └── schema/
│   │       ├── contents.ts          # NEW: Content + content_versions + content_references tables
│   │       ├── notifications.ts     # NEW: In-app notification table
│   │       └── index.ts             # MODIFY: Export new schemas
│   ├── api/
│   │   ├── routes/
│   │   │   └── contents.ts          # NEW: Content CRUD + versioning + diff API routes
│   │   ├── schemas/
│   │   │   └── contents.ts          # NEW: Zod validation schemas for content API
│   │   └── middleware/
│   │       └── permissions.ts       # MODIFY: Add content-specific permissions
│   ├── services/
│   │   ├── content/
│   │   │   ├── content-service.ts   # NEW: Core content CRUD + versioning logic
│   │   │   ├── version-service.ts   # NEW: Version creation, comparison, revert
│   │   │   ├── diff-service.ts      # NEW: Content diffing engine
│   │   │   ├── reference-service.ts # NEW: Cross-content reference tracking
│   │   │   └── index.ts            # NEW: Service exports
│   │   ├── notification/
│   │   │   ├── notification-service.ts # NEW: In-app + email notification dispatch
│   │   │   └── index.ts            # NEW: Service exports
│   │   └── workflow/
│   │       └── state-machine.ts     # MODIFY: Extend with content-aware guards
│   └── models/
│       └── content.ts               # NEW: Content model + Zod schemas
├── tests/
│   ├── unit/
│   │   ├── content-service.test.ts  # NEW: Content service unit tests
│   │   ├── version-service.test.ts  # NEW: Version service unit tests
│   │   └── diff-service.test.ts     # NEW: Diff service unit tests
│   ├── integration/
│   │   ├── content-api.test.ts      # NEW: Content API integration tests
│   │   ├── content-lifecycle.test.ts # NEW: Full lifecycle integration tests
│   │   └── immutability.test.ts     # NEW: Immutability enforcement tests
│   └── contract/
│       └── content-routes.test.ts   # NEW: API contract tests
└── drizzle/                         # Migration files (auto-generated)

frontend/
├── src/
│   ├── pages/
│   │   └── BranchWorkspace.tsx      # MODIFY: Integrate content authoring UI
│   ├── components/
│   │   ├── content/
│   │   │   ├── ContentEditor.tsx    # NEW: Monaco-based content editor
│   │   │   ├── ContentList.tsx      # NEW: Content items within a branch
│   │   │   ├── ContentMetadata.tsx  # NEW: Metadata editor (title, type, category, tags)
│   │   │   ├── VersionHistory.tsx   # NEW: Version timeline with attribution
│   │   │   ├── VersionDiff.tsx      # NEW: Side-by-side version comparison
│   │   │   ├── ContentLineage.tsx   # NEW: Visual lineage from published back to origin
│   │   │   └── ContentTypeSelector.tsx # NEW: Guideline / Asset / Opinion type picker
│   │   └── notification/
│   │       ├── NotificationBell.tsx # NEW: Header notification indicator
│   │       └── NotificationList.tsx # NEW: In-app notification panel
│   ├── services/
│   │   └── content-api.ts          # NEW: Content API client functions
│   ├── stores/
│   │   ├── contentStore.ts         # NEW: Content state (Zustand)
│   │   └── notificationStore.ts    # NEW: Notification state (Zustand)
│   └── hooks/
│       ├── useContent.ts           # NEW: Content data fetching hooks (React Query)
│       ├── useVersionHistory.ts    # NEW: Version history hooks
│       └── useNotifications.ts     # NEW: Notification hooks

shared/
├── types/
│   ├── content.ts                  # NEW: Content, Version, ContentReference interfaces
│   └── notification.ts             # NEW: Notification interfaces
└── constants/
    └── states.ts                   # MODIFY: Add content-specific states/types
```

**Structure Decision**: Web application structure matching existing echo-portal monorepo layout. New code follows established patterns: Hono routes + Drizzle schema + service layer (backend), React components + Zustand stores + React Query hooks (frontend), shared types/constants.

## Complexity Tracking

No Constitution violations. All design choices follow existing patterns.

---

## Data Model

### New Tables

#### `contents` - Content items within branches

```
contents
├── id: UUID (PK, default gen_random_uuid())
├── branch_id: UUID (FK → branches.id, NOT NULL)
├── title: TEXT (NOT NULL)
├── slug: TEXT (NOT NULL)
├── content_type: content_type_enum (NOT NULL)  -- 'guideline' | 'asset' | 'opinion'
├── category: TEXT
├── tags: TEXT[] (DEFAULT '{}')
├── description: TEXT
├── visibility: visibility_enum (DEFAULT 'private')
├── current_version_id: UUID (FK → content_versions.id, nullable)
├── is_published: BOOLEAN (DEFAULT false)
├── published_at: TIMESTAMPTZ
├── published_by: UUID (FK → users.id, nullable)
├── published_version_id: UUID (FK → content_versions.id, nullable)
├── source_content_id: UUID (FK → contents.id, nullable)  -- links to content this updates
├── created_by: UUID (FK → users.id, NOT NULL)
├── created_at: TIMESTAMPTZ (DEFAULT now())
├── updated_at: TIMESTAMPTZ (DEFAULT now())
├── archived_at: TIMESTAMPTZ
└── UNIQUE(branch_id, slug)
```

**Indexes**: `branch_id`, `content_type`, `is_published`, `created_by`, `source_content_id`, composite `(branch_id, content_type)`, GIN index on `tags`

#### `content_versions` - Immutable version snapshots

```
content_versions
├── id: UUID (PK, default gen_random_uuid())
├── content_id: UUID (FK → contents.id, NOT NULL)
├── version_timestamp: TIMESTAMPTZ (NOT NULL, DEFAULT now())  -- serves as version identifier
├── parent_version_id: UUID (FK → content_versions.id, nullable)
├── body: TEXT (NOT NULL)  -- content body (markdown, structured text)
├── body_format: TEXT (DEFAULT 'markdown')  -- 'markdown' | 'structured' | 'rich_text'
├── metadata_snapshot: JSONB (NOT NULL)  -- frozen copy of title, category, tags at this version
├── change_description: TEXT (NOT NULL)
├── author_id: UUID (FK → users.id, NOT NULL)
├── author_type: actor_type_enum (DEFAULT 'user')  -- 'user' | 'system' (for AI attribution)
├── byte_size: INTEGER (NOT NULL)  -- enforced <= 50MB (52,428,800 bytes)
├── checksum: TEXT (NOT NULL)  -- SHA-256 hash of body for integrity verification
├── is_revert: BOOLEAN (DEFAULT false)  -- marks versions created via revert
├── reverted_from_id: UUID (FK → content_versions.id, nullable)
├── created_at: TIMESTAMPTZ (DEFAULT now())
└── UNIQUE(content_id, version_timestamp)
```

**Indexes**: `content_id`, `version_timestamp`, `author_id`, composite `(content_id, version_timestamp DESC)` for efficient history retrieval

**Immutability enforcement**: No UPDATE or DELETE operations exposed at the service layer. Database-level trigger prevents UPDATE/DELETE on rows where the parent content is published.

#### `content_references` - Cross-content reference tracking

```
content_references
├── id: UUID (PK, default gen_random_uuid())
├── source_content_id: UUID (FK → contents.id, NOT NULL)
├── source_version_id: UUID (FK → content_versions.id, NOT NULL)
├── target_content_id: UUID (FK → contents.id, NOT NULL)
├── target_version_id: UUID (FK → content_versions.id, nullable)  -- null = latest
├── reference_type: TEXT (DEFAULT 'link')  -- 'link' | 'embed' | 'extends' | 'replaces'
├── created_at: TIMESTAMPTZ (DEFAULT now())
└── UNIQUE(source_version_id, target_content_id, reference_type)
```

**Indexes**: `source_content_id`, `target_content_id`, `source_version_id`

#### `notifications` - In-app notifications

```
notifications
├── id: UUID (PK, default gen_random_uuid())
├── user_id: UUID (FK → users.id, NOT NULL)
├── type: TEXT (NOT NULL)  -- 'review_requested' | 'review_completed' | 'changes_requested' | 'content_published'
├── title: TEXT (NOT NULL)
├── message: TEXT (NOT NULL)
├── resource_type: TEXT  -- 'content' | 'branch' | 'review'
├── resource_id: UUID
├── is_read: BOOLEAN (DEFAULT false)
├── created_at: TIMESTAMPTZ (DEFAULT now())
└── read_at: TIMESTAMPTZ
```

**Indexes**: `user_id`, composite `(user_id, is_read)`, `created_at`

### New Enums

```
content_type_enum: 'guideline' | 'asset' | 'opinion'
```

### Schema Relationships

```
branches (existing)
  └── contents (1:many via branch_id)
       ├── content_versions (1:many via content_id)
       │    └── content_references (1:many via source_version_id)
       ├── users (FK: created_by, published_by)
       └── contents (self-ref: source_content_id for update lineage)

users (existing)
  ├── content_versions (1:many via author_id)
  └── notifications (1:many via user_id)
```

### Migration Strategy

Additive migration only. New tables and enums are created alongside existing schema. No modification to existing tables required. The migration will be generated via `pnpm db:generate` and applied via `pnpm db:push`.

---

## API Design

All content routes are scoped under `/api/v1/contents` and require authentication (except published public content reads). Routes follow existing Hono patterns with Zod validation.

### Content CRUD

| Method | Endpoint | Auth | Description | FR |
|--------|----------|------|-------------|-----|
| `POST` | `/api/v1/contents` | Required | Create content within a branch | FR-001, FR-003, FR-007 |
| `GET` | `/api/v1/contents/:id` | Conditional | Get content with current version | FR-007, FR-017 |
| `PUT` | `/api/v1/contents/:id` | Required | Update content (creates new version) | FR-002, FR-003 |
| `GET` | `/api/v1/contents?branchId=X` | Required | List contents in a branch | FR-001 |
| `GET` | `/api/v1/contents/published` | Optional | List published content (public) | FR-005 |
| `GET` | `/api/v1/contents/search?q=X` | Optional | Search content by metadata | FR-016 |

### Versioning

| Method | Endpoint | Auth | Description | FR |
|--------|----------|------|-------------|-----|
| `GET` | `/api/v1/contents/:id/versions` | Conditional | List all versions with attribution | FR-006, FR-017 |
| `GET` | `/api/v1/contents/:id/versions/:versionId` | Conditional | Get specific version (read-only) | FR-017 |
| `GET` | `/api/v1/contents/:id/diff?from=T1&to=T2` | Conditional | Compare two versions | FR-008 |
| `POST` | `/api/v1/contents/:id/revert` | Required | Revert to a previous version | FR-009 |
| `GET` | `/api/v1/contents/:id/lineage` | Conditional | Get full lineage chain | FR-006, FR-014 |

### References

| Method | Endpoint | Auth | Description | FR |
|--------|----------|------|-------------|-----|
| `GET` | `/api/v1/contents/:id/references` | Conditional | Get content references | FR-019 |
| `GET` | `/api/v1/contents/:id/referenced-by` | Conditional | Get reverse references | FR-019 |

### Notifications

| Method | Endpoint | Auth | Description | FR |
|--------|----------|------|-------------|-----|
| `GET` | `/api/v1/notifications` | Required | List user notifications | FR-022 |
| `PATCH` | `/api/v1/notifications/:id/read` | Required | Mark notification as read | FR-022 |
| `GET` | `/api/v1/notifications/unread-count` | Required | Get unread count | FR-022 |

### Request/Response Contracts

**POST /api/v1/contents** (Create Content)
```
Request:
{
  branchId: UUID (required),
  title: string (required, 1-500 chars),
  contentType: 'guideline' | 'asset' | 'opinion' (required),
  category: string (optional),
  tags: string[] (optional),
  description: string (optional),
  body: string (required, <= 50MB),
  bodyFormat: 'markdown' | 'structured' | 'rich_text' (default: 'markdown'),
  changeDescription: string (required, 1-2000 chars)
}

Response (201):
{
  data: {
    id: UUID,
    branchId: UUID,
    title: string,
    slug: string,
    contentType: string,
    currentVersion: {
      id: UUID,
      versionTimestamp: string (ISO 8601),
      body: string,
      changeDescription: string,
      author: { id: UUID, displayName: string, avatarUrl: string },
      authorType: 'user' | 'system',
      byteSize: number,
      checksum: string
    },
    createdBy: { id: UUID, displayName: string },
    createdAt: string
  }
}
```

**PUT /api/v1/contents/:id** (Update Content → Creates New Version)
```
Request:
{
  title: string (optional, updates metadata),
  category: string (optional),
  tags: string[] (optional),
  description: string (optional),
  body: string (required, <= 50MB),
  bodyFormat: string (optional),
  changeDescription: string (required)
}

Response (200):
{
  data: {
    ...content,
    currentVersion: { ...newVersion },
    previousVersion: { id, versionTimestamp }
  }
}
```

**GET /api/v1/contents/:id/diff?from=T1&to=T2** (Version Comparison)
```
Response (200):
{
  data: {
    contentId: UUID,
    from: { versionTimestamp, author, changeDescription },
    to: { versionTimestamp, author, changeDescription },
    diff: {
      bodyChanges: [
        { type: 'add' | 'remove' | 'modify', lineStart, lineEnd, content }
      ],
      metadataChanges: [
        { field: string, oldValue: any, newValue: any }
      ]
    },
    summary: { additions: number, deletions: number, modifications: number }
  }
}
```

### Guardrails (enforced at API layer)

1. **Branch binding**: `POST /contents` rejects requests without a valid `branchId` (FR-001)
2. **Published immutability**: `PUT /contents/:id` returns `403 Forbidden` if the content's branch is in `published` or `archived` state (FR-005)
3. **Size limit**: `POST` and `PUT` reject bodies > 50 MB with `413 Content Too Large` (FR-025)
4. **Version immutability**: No `PUT` or `DELETE` endpoints for individual versions (FR-002, FR-011)
5. **Lifecycle enforcement**: Content operations validate branch state via existing workflow middleware (FR-013)
6. **Permission checks**: All endpoints validate actor permissions via existing RBAC middleware (FR-013)

---

## Service Layer Design

### ContentService

Core orchestrator for content operations. Enforces business rules before delegating to database/version services.

**Key behaviors**:
- `create(input, actorContext)`: Validates branch ownership, generates slug, creates content + initial version, logs audit event
- `update(contentId, input, actorContext)`: Validates branch state (must be draft), creates new version via VersionService, updates `current_version_id`, logs audit event
- `getById(contentId, actorContext)`: Validates visibility/access, returns content with current version
- `listByBranch(branchId, actorContext)`: Returns all content in branch with access filtering
- `listPublished(filters)`: Returns published public content (no auth required for public)
- `search(query, filters, actorContext)`: Full-text search across title, description, tags, category

**Immutability enforcement**:
- `update()` checks `branch.state === 'draft'` before allowing modifications
- `update()` never modifies existing `content_versions` rows; always inserts new row
- Published content has `is_published = true`; any modification attempt on published content returns error

### VersionService

Manages version lifecycle, including creation, retrieval, and revert operations.

**Key behaviors**:
- `createVersion(contentId, input, actorContext)`: Creates immutable version row with ISO 8601 timestamp, SHA-256 checksum, author attribution
- `getVersions(contentId, pagination)`: Returns versions ordered by `version_timestamp DESC` with author details
- `getVersion(contentId, versionTimestamp)`: Returns specific version (read-only)
- `revert(contentId, targetVersionTimestamp, actorContext)`: Creates NEW version with body copied from target, sets `is_revert = true` and `reverted_from_id`

**Version ID strategy**: Each version is identified by its `version_timestamp` (ISO 8601 with millisecond precision). The `UNIQUE(content_id, version_timestamp)` constraint prevents collisions. In the unlikely event of a timestamp collision within the same content item, the service retries with an incremented millisecond.

### DiffService

Computes structured diffs between two content versions.

**Key behaviors**:
- `diff(contentId, fromTimestamp, toTimestamp)`: Fetches both versions, computes line-by-line diff of body, compares metadata snapshots
- Uses a text diffing algorithm (line-based diff suitable for markdown/structured content)
- Returns structured diff with additions, deletions, and modifications counts
- Metadata changes tracked separately (title, category, tags changes between versions)

### ReferenceService

Tracks and validates cross-content references.

**Key behaviors**:
- `recordReferences(sourceVersionId, references[])`: Parses content body for internal links, records in `content_references`
- `getReferences(contentId)`: Returns all outgoing references from latest version
- `getReferencedBy(contentId)`: Returns all incoming references (reverse lookup)
- `validateReferences(contentId)`: Checks that all referenced content still exists and is accessible

### NotificationService

Dispatches in-app and email notifications for review-related events.

**Key behaviors**:
- `notifyReviewRequested(reviewerIds[], branchId, contentSummary)`: Creates in-app notification + sends email
- `notifyReviewCompleted(authorId, decision, reviewerName)`: Notifies author of review outcome
- `notifyContentPublished(subscriberIds[], contentId)`: Notifies stakeholders of publication
- `getNotifications(userId, pagination)`: Returns user's notifications with read/unread filtering
- `markRead(notificationId, userId)`: Marks notification as read

Email dispatch is handled asynchronously (fire-and-forget with error logging). In-app notifications are persisted to the `notifications` table.

---

## Workflow Integration

### XState Machine Extensions

The existing `BranchMachine` (in `workflow/state-machine.ts`) needs content-aware guards added:

**New guards**:
- `hasContentInBranch`: Validates branch has at least one content item before allowing `SUBMIT_FOR_REVIEW`
- `contentNotExceedsSize`: Validates no content item exceeds 50 MB limit

**New actions on transitions**:
- `PUBLISH` event: Triggers `ContentService.markPublished()` which sets `is_published = true`, `published_at`, `published_by`, `published_version_id` on all content items in the branch
- `ARCHIVE` event: Triggers `ContentService.markArchived()` which sets `archived_at` on all content items

### Permission Extensions

New permissions added to existing RBAC model (in `permissions.ts`):

```
content:create   - Create content within own branches (contributor+)
content:read     - Read content (access filtered by visibility)
content:update   - Modify draft content in own branches (contributor+)
content:revert   - Revert to previous version (contributor+)
content:publish  - Publish approved content (publisher+)
content:archive  - Archive published content (admin)
content:search   - Search across all accessible content (all authenticated)
```

These map to existing role hierarchy: viewer < contributor < reviewer < administrator.

---

## Frontend Design

### Content Editor (ContentEditor.tsx)

Built on existing Monaco Editor integration (already in frontend dependencies).

**Features**:
- Markdown editing with syntax highlighting and preview
- Auto-save drafts to localStorage (not versioned until explicit save)
- Save action creates new version with required change description prompt
- Version indicator showing current version timestamp and author
- Unsaved changes warning on navigation

### Version History Panel (VersionHistory.tsx)

Displayed alongside editor or as slide-out panel.

**Features**:
- Chronological list of versions with timestamp, author avatar, and change description
- Visual indicator for reverted versions (linked to source)
- Click any version to view read-only snapshot
- "Compare" button to select two versions for diff view
- "Revert to this version" action (with confirmation dialog)

### Version Diff View (VersionDiff.tsx)

Side-by-side or inline diff visualization.

**Features**:
- Line-by-line diff with additions (green), deletions (red), modifications (yellow)
- Metadata changes section showing field-level differences
- Navigation between diff chunks
- "From" and "To" version selectors for comparing arbitrary versions

### Content List (ContentList.tsx)

Displayed within BranchWorkspace page.

**Features**:
- List of content items in current branch with type icons (guideline/asset/opinion)
- Current version timestamp and author for each item
- Status indicators (draft, in review, published)
- Create new content button
- Filter by content type, category, tags

### Notification UI (NotificationBell.tsx, NotificationList.tsx)

**Features**:
- Bell icon in AppHeader with unread count badge
- Dropdown panel showing recent notifications
- Click notification navigates to relevant content/branch
- Mark as read (individual and bulk)
- Poll for new notifications every 30 seconds (via React Query)

### State Management

**contentStore (Zustand)**:
- `currentContent`: Active content being edited
- `versions`: Cached version list for current content
- `isDirty`: Unsaved changes flag
- `isLoading`: Loading state

**notificationStore (Zustand)**:
- `unreadCount`: Badge counter
- `notifications`: Cached notification list

**React Query hooks**:
- `useContent(id)`: Fetch content with current version
- `useContentList(branchId)`: Fetch branch contents
- `useVersionHistory(contentId)`: Paginated version list
- `useVersionDiff(contentId, from, to)`: Diff between versions
- `useNotifications()`: Notification list with polling

---

## AI-Assisted Authoring Integration

AI-assisted content follows identical rules as human contributions (FR-012):

1. **Attribution**: AI-generated versions have `author_type = 'system'` and `author_id` set to the AI service account UUID. The `change_description` includes the AI model/agent identifier.

2. **Branch binding**: AI creates content only within branches it has been granted access to. The existing RBAC permission system applies.

3. **Version creation**: Every AI modification creates a new version via the same `ContentService.update()` path. No bypass mechanism exists.

4. **Review requirement**: AI-authored content follows the same `Draft → Review → Approved → Published` lifecycle. AI cannot self-approve.

5. **Audit trail**: All AI actions are logged with `actor_type = 'system'` and full metadata including the initiating human user (if applicable) via the `initiating_user_id` field in audit logs.

6. **API access**: AI agents authenticate via the existing API token mechanism (`auth_provider = 'api_token'`). The same rate limits and permission checks apply.

---

## Edge Cases and Error Handling

### Concurrent Edits

**Scenario**: Two users modify the same content in the same branch simultaneously.

**Strategy**: Optimistic concurrency control. Each `PUT /contents/:id` request includes the `currentVersionTimestamp` of the version the edit is based on. If the server's current version differs, the request fails with `409 Conflict` and returns the current version for the client to merge or retry.

### Abandoned Drafts

**Scenario**: User creates a branch, adds content, but never submits for review.

**Strategy**: No automatic cleanup. Branches in draft state persist indefinitely (consistent with existing branch behavior). Administrators can archive abandoned branches. The content and all versions remain accessible for audit purposes.

### Version Divergence

**Scenario**: Two branches modify content that originated from the same published source.

**Strategy**: When publishing (convergence), the system detects that the source content has been modified by another branch since the fork. The author must manually resolve conflicts by viewing both versions side-by-side and selecting/merging changes before re-submitting for review (FR-021). The conflict detection compares `source_content_id` and its current `published_version_id` against the `parent_version_id` chain of the branch's content.

### Rollback Scenarios

**Scenario**: Published content needs to be corrected.

**Strategy**: Published content is immutable (FR-005). To correct published content:
1. Create a new branch linked to the published content via `source_content_id`
2. Make corrections as new versions within that branch
3. Follow the standard review/approval/publish workflow
4. The new publication supersedes the old one (but old version remains accessible)

### Cross-Branch Conflicts

**Scenario**: Two branches modify content that references the same published source.

**Strategy**: Second branch to publish detects the conflict via `source_content_id` comparison. Author sees a diff between their version and the newly published version, and must reconcile before proceeding.

### Size Limit Enforcement

**Scenario**: Content upload exceeds 50 MB.

**Strategy**: Size checked at two levels:
1. Frontend: File size validation before upload (fast feedback)
2. Backend: `byte_size` calculated from body; request rejected with `413` if > 52,428,800 bytes

### Deactivated Author

**Scenario**: Content author's account is deactivated.

**Strategy**: Content attribution is immutable (author_id in content_versions is never changed). The deactivated user's display name continues to appear in version history. Administrators can transfer branch ownership but cannot alter historical attribution.

---

## Testing Strategy

### Unit Tests

**ContentService** (`content-service.test.ts`):
- Creates content with valid branch and returns versioned result
- Rejects content creation without branch ID
- Rejects content exceeding 50 MB size limit
- Rejects modification of published content
- Rejects modification when branch is not in draft state
- Correctly generates slug from title

**VersionService** (`version-service.test.ts`):
- Creates immutable version with ISO 8601 timestamp
- Computes correct SHA-256 checksum
- Revert creates new version (not modifying history)
- Version listing returns correct chronological order
- Handles timestamp collision with retry

**DiffService** (`diff-service.test.ts`):
- Correctly identifies additions, deletions, and modifications
- Handles empty content comparison
- Handles identical content comparison
- Metadata diff captures field-level changes

### Integration Tests

**Content API** (`content-api.test.ts`):
- Full CRUD lifecycle: create, read, update, list, search
- Permission enforcement: contributor can create, viewer cannot
- Branch binding: content creation fails without branch context
- Published content returns read-only (no update endpoint)
- Version history returns complete chain
- Diff API returns correct comparison

**Content Lifecycle** (`content-lifecycle.test.ts`):
- Draft → Review → Approved → Published full flow
- Published content immutability enforcement
- Archive preserves all history
- Revert creates new version with correct lineage
- Review notification dispatched on submission

**Immutability Enforcement** (`immutability.test.ts`):
- Published content rejects all modification attempts
- Version rows cannot be updated or deleted via API
- Archived content cannot be modified
- Published version checksum matches original

### Contract Tests

**Content Routes** (`content-routes.test.ts`):
- All endpoints return correct status codes
- Request validation rejects invalid payloads
- Response shapes match documented contracts
- Error responses include correct error codes

### Performance Tests

- Version history retrieval for content with 1,000+ versions: < 3 seconds (SC-003)
- Version comparison: < 5 seconds (SC-007)
- Content search across 10,000+ items: < 3 seconds
- Concurrent content creation by 100 users: no errors, no version collision

---

## Implementation Phases

### Phase 1: Data Foundation (Database + Shared Types)
- Create database schema: `contents`, `content_versions`, `content_references`, `notifications` tables
- Add `content_type_enum` enum
- Generate and apply Drizzle migration
- Create shared types: `Content`, `ContentVersion`, `ContentReference`, `Notification` interfaces
- Add content-specific constants to shared package
- **Validates**: Schema supports all FR requirements

### Phase 2: Core Content Service (Backend CRUD + Versioning)
- Implement `ContentService`: create, update, getById, listByBranch, search
- Implement `VersionService`: createVersion, getVersions, getVersion, revert
- Implement content model with Zod validation schemas
- Add content-specific permissions to RBAC middleware
- Enforce branch binding, size limits, and lifecycle state checks
- Write unit tests for all service methods
- **Validates**: FR-001 through FR-007, FR-009, FR-011, FR-012, FR-013, FR-024, FR-025

### Phase 3: Content API Routes
- Implement all content CRUD routes (`/api/v1/contents/*`)
- Implement version routes (history, specific version, revert)
- Implement search endpoint
- Add Zod request validation schemas
- Wire up audit logging for all content events
- Write integration tests and contract tests
- **Validates**: FR-016, FR-017, FR-020, SC-001

### Phase 4: Diff Engine + Reference Tracking
- Implement `DiffService`: line-by-line diff, metadata diff
- Implement diff API route
- Implement `ReferenceService`: reference recording, lookup, validation
- Implement lineage API route
- Write unit tests for diff accuracy
- **Validates**: FR-008, FR-014, FR-019, SC-007

### Phase 5: Workflow Integration + Immutability
- Extend XState machine with content-aware guards
- Implement `markPublished()` and `markArchived()` actions on state transitions
- Add published content immutability enforcement (service + API layers)
- Implement conflict detection for convergence operations
- Write immutability enforcement tests
- **Validates**: FR-004, FR-005, FR-013, FR-018, FR-021, FR-023, SC-005

### Phase 6: Notification System
- Create `NotificationService` with in-app + email dispatch
- Implement notification API routes
- Wire up notifications on review submission, approval, publication
- **Validates**: FR-022

### Phase 7: Frontend Content Editor
- Implement `ContentEditor` (Monaco-based)
- Implement `ContentList`, `ContentMetadata`, `ContentTypeSelector`
- Implement `contentStore` (Zustand) and `useContent` hooks (React Query)
- Integrate into `BranchWorkspace` page
- **Validates**: SC-001, SC-008

### Phase 8: Frontend Version History + Diff
- Implement `VersionHistory` timeline panel
- Implement `VersionDiff` side-by-side view
- Implement `ContentLineage` visualization
- Add revert UI with confirmation dialog
- **Validates**: SC-003, SC-007, SC-012

### Phase 9: Frontend Notifications
- Implement `NotificationBell` and `NotificationList`
- Add notification polling (30s interval)
- Integrate into `AppHeader`
- **Validates**: FR-022

### Phase 10: End-to-End Testing + Performance
- Full lifecycle E2E tests (create → modify → review → publish → audit)
- Performance benchmarks against SC targets
- Concurrent operation testing
- Edge case regression suite
- **Validates**: All SC criteria, all edge cases

---

## Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Timestamp collision for versions | Data integrity | UNIQUE constraint + millisecond retry in VersionService |
| 50 MB content causing slow queries | Performance | Size stored as integer field; body loaded only when requested (not in list queries) |
| Email delivery failures for notifications | User experience | In-app notification is primary; email is async fire-and-forget with error logging |
| Large version histories slowing UI | UX | Paginated version API (default 50 per page); React Query infinite scroll |
| Concurrent edit conflicts frustrating users | UX | Optimistic concurrency with clear conflict UI; auto-save drafts locally |

---

## Dependencies on Existing Features

| Dependency | Feature | Status |
|------------|---------|--------|
| Branch CRUD and lifecycle | 001-branch-isolation-model | Implemented |
| User authentication and RBAC | 002-identity-roles-permissions | Implemented |
| XState workflow machine | 001-branch-isolation-model | Implemented |
| Review workflow | 001-branch-isolation-model | Implemented |
| Audit logging infrastructure | 002-identity-roles-permissions | Implemented |
| Git repository operations | 001-branch-isolation-model | Implemented |
| Convergence/merge operations | 001-branch-isolation-model | Implemented |

All required infrastructure is in place. This feature builds on top of existing systems without requiring changes to their core contracts.
